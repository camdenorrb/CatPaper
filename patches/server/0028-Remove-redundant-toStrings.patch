From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Sat, 22 Oct 2022 03:53:33 -0500
Subject: [PATCH] Remove redundant toStrings


diff --git a/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadPool.java b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadPool.java
index 2bf15e54237a2e201405aaa990fdd2572fb30adb..1e10a7c19d280a66484a29f5626bd488952c91e8 100644
--- a/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadPool.java
+++ b/src/main/java/ca/spottedleaf/concurrentutil/executor/standard/PrioritisedThreadPool.java
@@ -76,7 +76,7 @@ public final class PrioritisedThreadPool {
     public @NotNull PrioritisedPoolExecutor createExecutor(final String name, final int parallelism) {
         synchronized (this.nonShutdownQueues) {
             if (this.shutdown) {
-                throw new IllegalStateException("Queue is shutdown: " + this.toString());
+                throw new IllegalStateException("Queue is shutdown: " + this);
             }
             final PrioritisedPoolExecutorImpl ret = new PrioritisedPoolExecutorImpl(this, name, Math.min(Math.max(1, parallelism), this.threads.length));
 
@@ -281,7 +281,7 @@ public final class PrioritisedThreadPool {
                     } catch (final ThreadDeath death) {
                         throw death; // goodbye world...
                     } catch (final Throwable throwable) {
-                        LOGGER.error("Exception thrown from thread '" + this.getName() + "' in queue '" + queue.toString() + "'", throwable);
+                        LOGGER.error("Exception thrown from thread '" + this.getName() + "' in queue '" + queue + "'", throwable);
                     }
                 } while (!this.isAlertedHighPriority() && System.nanoTime() <= deadline);
 
diff --git a/src/main/java/ca/spottedleaf/concurrentutil/util/ConcurrentUtil.java b/src/main/java/ca/spottedleaf/concurrentutil/util/ConcurrentUtil.java
index 06ae16fde9bbe8686ad00c8cd489955be7953417..214eee49c0cefbe33f625793633422ae74cd29dd 100644
--- a/src/main/java/ca/spottedleaf/concurrentutil/util/ConcurrentUtil.java
+++ b/src/main/java/ca/spottedleaf/concurrentutil/util/ConcurrentUtil.java
@@ -10,7 +10,7 @@ import java.util.concurrent.locks.LockSupport;
 public final class ConcurrentUtil {
 
     public static @NotNull String genericToString(final @Nullable Object object) {
-        return object == null ? "null" : object.getClass().getName() + ":" + object.hashCode() + ":" + object.toString();
+        return object == null ? "null" : object.getClass().getName() + ":" + object.hashCode() + ":" + object;
     }
 
     public static void rethrow(Throwable exception) {
diff --git a/src/main/java/co/aikar/timings/MinecraftTimings.java b/src/main/java/co/aikar/timings/MinecraftTimings.java
index 66c587782fd439889278f48bd22926277c41e016..bcd1b40893f5828bc099abec28320510d1697e52 100644
--- a/src/main/java/co/aikar/timings/MinecraftTimings.java
+++ b/src/main/java/co/aikar/timings/MinecraftTimings.java
@@ -148,7 +148,7 @@ public final class MinecraftTimings {
     }
 
     public static @NotNull Timing getBlockTiming(@NotNull Block block) {
-        return Timings.ofSafe("## Scheduled Block: " + block.toString(), scheduledBlocksTimer);
+        return Timings.ofSafe("## Scheduled Block: " + block, scheduledBlocksTimer);
     }
 /*
     public static Timing getStructureTiming(StructureGenerator structureGenerator) {
diff --git a/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java b/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
index f75156ebc4cf71ecc73cdedd02bdc216fce025e6..0473adbcca6c8a4710236662eb0165b27a6091e0 100644
--- a/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
+++ b/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
@@ -47,7 +47,7 @@ public class PaperVersionFetcher implements VersionFetcher {
                 mcVer = result.substring(0, result.length() - 2); // strip 'R' anchor and trailing '-'
             } else {
                 org.bukkit.Bukkit.getLogger().warning("Unable to match version to pattern! Report to PaperMC!");
-                org.bukkit.Bukkit.getLogger().warning("Pattern: " + VER_PATTERN.toString());
+                org.bukkit.Bukkit.getLogger().warning("Pattern: " + VER_PATTERN);
                 org.bukkit.Bukkit.getLogger().warning("Version: " + org.bukkit.Bukkit.getBukkitVersion());
             }
         }
diff --git a/src/main/java/com/destroystokyo/paper/io/IOUtil.java b/src/main/java/com/destroystokyo/paper/io/IOUtil.java
index 2354797f04c8208719ae0dcdc254ec693800ec2d..e62c06a56fca5a780e21ee8894d6d04316f4f19b 100644
--- a/src/main/java/com/destroystokyo/paper/io/IOUtil.java
+++ b/src/main/java/com/destroystokyo/paper/io/IOUtil.java
@@ -31,7 +31,7 @@ public final class IOUtil {
     }
 
     public static @NotNull String genericToString(final @Nullable Object object) {
-        return object == null ? "null" : object.getClass().getName() + ":" + object.toString();
+        return object == null ? "null" : object.getClass().getName() + ":" + object;
     }
 
     public static <T> @NotNull T notNull(final @Nullable T obj) {
diff --git a/src/main/java/com/destroystokyo/paper/util/PooledHashSets.java b/src/main/java/com/destroystokyo/paper/util/PooledHashSets.java
index 7280c57aaee9856988b739b6ef6f82604ad90e96..37d172017ab34650575cfb51f42e7ef30d9b09f7 100644
--- a/src/main/java/com/destroystokyo/paper/util/PooledHashSets.java
+++ b/src/main/java/com/destroystokyo/paper/util/PooledHashSets.java
@@ -238,7 +238,7 @@ public class PooledHashSets<E> {
         @Override
         public @NotNull String toString() {
             return "PooledHashSet: size: " + this.set.size() + ", reference count: " + this.referenceCount + ", hash: " +
-                this.hashCode() + ", identity: " + System.identityHashCode(this) + " map: " + this.set.toString();
+                this.hashCode() + ", identity: " + System.identityHashCode(this) + " map: " + this.set;
         }
     }
 } 
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
index 7080532228afe4619a9f107ad2a309be175cacaa..0cb91bbaf6e1e15531d2b531b5781135cc1d4a5d 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
@@ -215,7 +215,7 @@ public abstract class AreaMap<E> {
         if (current != null) {
             PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> next = this.pooledHashSets.findMapWith(current, object);
             if (next == current) {
-                throw new IllegalStateException("Expected different map: got " + next.toString());
+                throw new IllegalStateException("Expected different map: got " + next);
             }
             this.areaMap.put(key, next);
 
@@ -250,7 +250,7 @@ public abstract class AreaMap<E> {
         PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> next = this.pooledHashSets.findMapWithout(current, object);
 
         if (next == current) {
-            throw new IllegalStateException("Current map [" + next.toString() + "] should have contained " + object + ", (" + chunkX + "," + chunkZ + ")");
+            throw new IllegalStateException("Current map [" + next + "] should have contained " + object + ", (" + chunkX + "," + chunkZ + ")");
         }
 
         if (next != null) {
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java b/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
index 5d60a88196e0a23c3fdaad19f84254f274005f7b..1852d8c22303167f6173f67fee452355c8b37a77 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
@@ -284,7 +284,7 @@ public class PooledLinkedHashSets<E> {
         @Override
         public @NotNull String toString() {
             return "PooledHashSet: size: " + this.set.size() + ", reference count: " + this.referenceCount + ", hash: " +
-                this.hashCode() + ", identity: " + System.identityHashCode(this) + " map: " + this.set.toString();
+                this.hashCode() + ", identity: " + System.identityHashCode(this) + " map: " + this.set;
         }
     }
 }
diff --git a/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java b/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
index 852695880552b75d48b2b1556597bef4ac844d2a..7ca2722ed6c27a01a4078361366cb9f7b04107a2 100644
--- a/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
+++ b/src/main/java/io/papermc/paper/chunk/SingleThreadChunkRegionManager.java
@@ -408,7 +408,7 @@ public final class SingleThreadChunkRegionManager {
             final long bitset = this.chunksBitset[index >>> 6]; // index / Long.SIZE
             final long after = this.chunksBitset[index >>> 6] = bitset | (1L << (index & (Long.SIZE - 1)));
             if (after == bitset) {
-                throw new IllegalStateException("Cannot add a chunk to a section which already has the chunk! RegionSection: " + this + ", global chunk: " + new ChunkPos(chunkX, chunkZ).toString());
+                throw new IllegalStateException("Cannot add a chunk to a section which already has the chunk! RegionSection: " + this + ", global chunk: " + new ChunkPos(chunkX, chunkZ));
             }
             if (++this.chunkCount != 1) {
                 return;
@@ -421,7 +421,7 @@ public final class SingleThreadChunkRegionManager {
             final long before = this.chunksBitset[index >>> 6]; // index / Long.SIZE
             final long bitset = this.chunksBitset[index >>> 6] = before & ~(1L << (index & (Long.SIZE - 1)));
             if (before == bitset) {
-                throw new IllegalStateException("Cannot remove a chunk from a section which does not have that chunk! RegionSection: " + this + ", global chunk: " + new ChunkPos(chunkX, chunkZ).toString());
+                throw new IllegalStateException("Cannot remove a chunk from a section which does not have that chunk! RegionSection: " + this + ", global chunk: " + new ChunkPos(chunkX, chunkZ));
             }
             if (--this.chunkCount != 0) {
                 return;
@@ -432,7 +432,7 @@ public final class SingleThreadChunkRegionManager {
         @Override
         public @NotNull String toString() {
             return "RegionSection{" +
-                    "regionCoordinate=" + new ChunkPos(this.regionCoordinate).toString() + "," +
+                    "regionCoordinate=" + new ChunkPos(this.regionCoordinate) + "," +
                     "chunkCount=" + this.chunkCount + "," +
                     "chunksBitset=" + toString(this.chunksBitset) + "," +
                     "hash=" + this.hashCode() +
@@ -441,7 +441,7 @@ public final class SingleThreadChunkRegionManager {
 
         public @NotNull String toStringWithRegion() {
             return "RegionSection{" +
-                    "regionCoordinate=" + new ChunkPos(this.regionCoordinate).toString() + "," +
+                    "regionCoordinate=" + new ChunkPos(this.regionCoordinate) + "," +
                     "chunkCount=" + this.chunkCount + "," +
                     "chunksBitset=" + toString(this.chunksBitset) + "," +
                     "hash=" + this.hashCode() + "," +
diff --git a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
index fa9c36abd8d22f1d777688e9085b94595d46c552..07a5e2d5d0e0a6dce0c59586ae2f010b129eac30 100644
--- a/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
+++ b/src/main/java/io/papermc/paper/chunk/system/io/RegionFileIOThread.java
@@ -1043,7 +1043,7 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                 } catch (final ThreadDeath thr) {
                     throw thr;
                 } catch (final Throwable thr) {
-                    LOGGER.error("Callback " + ConcurrentUtil.genericToString(consumer) + " failed to handle chunk data for task " + task.toString(), thr);
+                    LOGGER.error("Callback " + ConcurrentUtil.genericToString(consumer) + " failed to handle chunk data for task " + task, thr);
                 }
             }
         }
@@ -1220,10 +1220,10 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                     // cancelled read? go to task controller to confirm
                     final ChunkDataTask inMap = this.taskController.tasks.compute(chunkKey, (final @NotNull ChunkCoordinate keyInMap, final @NotNull ChunkDataTask valueInMap) -> {
                         if (valueInMap == null) {
-                            throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
+                            throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this + ", report this!");
                         }
                         if (valueInMap != ChunkDataTask.this) {
-                            throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
+                            throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this + ", got: " + valueInMap + ", report this!");
                         }
 
                         if (!read.waiters.isEmpty()) { // as per usual IntelliJ is unable to figure out that there are concurrent accesses.
@@ -1254,7 +1254,7 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                         throw thr;
                     } catch (final Throwable thr) {
                         throwable = thr;
-                        LOGGER.error("Failed to read chunk data for task: " + this.toString(), thr);
+                        LOGGER.error("Failed to read chunk data for task: " + this, thr);
                     }
                     read.complete(this, compound, throwable);
                 }
@@ -1265,10 +1265,10 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
             if (write == NOTHING_TO_WRITE) {
                 final ChunkDataTask inMap = this.taskController.tasks.compute(chunkKey, (final @NotNull ChunkCoordinate keyInMap, final @NotNull ChunkDataTask valueInMap) -> {
                     if (valueInMap == null) {
-                        throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
+                        throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this + ", report this!");
                     }
                     if (valueInMap != ChunkDataTask.this) {
-                        throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
+                        throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this + ", got: " + valueInMap + ", report this!");
                     }
                     return valueInMap.inProgressWrite == NOTHING_TO_WRITE ? null : valueInMap;
                 });
@@ -1294,7 +1294,7 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
                         LOGGER.error("Chunk at (" + this.chunkX + "," + this.chunkZ + ") in '" + this.world.getWorld().getName() + "' exceeds max size of " + maxSize + "MiB, it has been deleted from disk.");
                     } else {
                         failedWrite = thr instanceof IOException;
-                        LOGGER.error("Failed to write chunk data for task: " + this.toString(), thr);
+                        LOGGER.error("Failed to write chunk data for task: " + this, thr);
                     }
                 }
 
@@ -1303,10 +1303,10 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
 
                 this.taskController.tasks.compute(chunkKey, (final @NotNull ChunkCoordinate keyInMap, final @NotNull ChunkDataTask valueInMap) -> {
                     if (valueInMap == null) {
-                        throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
+                        throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this + ", report this!");
                     }
                     if (valueInMap != ChunkDataTask.this) {
-                        throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
+                        throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this + ", got: " + valueInMap + ", report this!");
                     }
                     if (valueInMap.inProgressWrite == dataWritten) {
                         valueInMap.failedWrite = finalFailWrite;
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
index 5b43b7bedc31ff4f00b0dbb66d1e06208798b3ea..f1e568e3e5c753796d39bdbb77bcbe30cc98f3d6 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLightTask.java
@@ -164,7 +164,7 @@ public final class ChunkLightTask extends ChunkProgressionTask {
                 }
             } catch (final Throwable thr) {
                 if (!(thr instanceof ThreadDeath)) {
-                    LOGGER.fatal("Failed to light chunk " + task.fromChunk.getPos().toString() + " in world '" + this.lightEngine.getWorld().getWorld().getName() + "'", thr);
+                    LOGGER.fatal("Failed to light chunk " + task.fromChunk.getPos() + " in world '" + this.lightEngine.getWorld().getWorld().getName() + "'", thr);
                 }
 
                 task.complete(null, thr);
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java
index 89a5537f3a789b48e7a0c1ebbd332dc923b8b726..9ea6e60bf5374d6881962ab1447ada6fb227b632 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkLoadTask.java
@@ -285,7 +285,7 @@ public final class ChunkLoadTask extends ChunkProgressionTask {
 
             final PoiChunk poiChunk = ChunkLoadTask.this.chunkHolder.getPoiChunk();
             if (poiChunk == null) {
-                LOGGER.error("Expected poi chunk to be loaded with chunk for task " + this.toString());
+                LOGGER.error("Expected poi chunk to be loaded with chunk for task " + this);
             } else if (!poiChunk.isLoaded()) {
                 // need to call poiChunk.load() on main
                 return null;
@@ -297,7 +297,7 @@ public final class ChunkLoadTask extends ChunkProgressionTask {
         @Override
         protected @NotNull TaskResult<ChunkSerializer.InProgressChunkHolder, Throwable> runOffMain(final @Nullable CompoundTag data, final @Nullable Throwable throwable) {
             if (throwable != null) {
-                LOGGER.error("Failed to load chunk data for task: " + this.toString() + ", chunk data will be lost", throwable);
+                LOGGER.error("Failed to load chunk data for task: " + this + ", chunk data will be lost", throwable);
                 return new TaskResult<>(null, null);
             }
 
@@ -325,7 +325,7 @@ public final class ChunkLoadTask extends ChunkProgressionTask {
             } catch (final ThreadDeath death) {
                 throw death;
             } catch (final Throwable thr2) {
-                LOGGER.error("Failed to parse chunk data for task: " + this.toString() + ", chunk data will be lost", thr2);
+                LOGGER.error("Failed to parse chunk data for task: " + this + ", chunk data will be lost", thr2);
                 return new TaskResult<>(null, thr2);
             }
         }
@@ -341,7 +341,7 @@ public final class ChunkLoadTask extends ChunkProgressionTask {
         protected @NotNull TaskResult<ChunkAccess, Throwable> runOnMain(final ChunkSerializer.@Nullable InProgressChunkHolder data, final Throwable throwable) {
             final PoiChunk poiChunk = ChunkLoadTask.this.chunkHolder.getPoiChunk();
             if (poiChunk == null) {
-                LOGGER.error("Expected poi chunk to be loaded with chunk for task " + this.toString());
+                LOGGER.error("Expected poi chunk to be loaded with chunk for task " + this);
             } else {
                 poiChunk.load();
             }
@@ -365,7 +365,7 @@ public final class ChunkLoadTask extends ChunkProgressionTask {
             } catch (final ThreadDeath death) {
                 throw death;
             } catch (final Throwable thr2) {
-                LOGGER.error("Failed to parse main tasks for task " + this.toString() + ", chunk data will be lost", thr2);
+                LOGGER.error("Failed to parse main tasks for task " + this + ", chunk data will be lost", thr2);
                 return new TaskResult<>(this.getEmptyChunk(), null);
             }
         }
@@ -405,7 +405,7 @@ public final class ChunkLoadTask extends ChunkProgressionTask {
         @Override
         protected @NotNull TaskResult<PoiChunk, Throwable> runOffMain(@Nullable CompoundTag data, final @Nullable Throwable throwable) {
             if (throwable != null) {
-                LOGGER.error("Failed to load poi data for task: " + this.toString() + ", poi data will be lost", throwable);
+                LOGGER.error("Failed to load poi data for task: " + this + ", poi data will be lost", throwable);
                 return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
             }
 
@@ -427,7 +427,7 @@ public final class ChunkLoadTask extends ChunkProgressionTask {
             } catch (final ThreadDeath death) {
                 throw death;
             } catch (final Throwable thr2) {
-                LOGGER.error("Failed to run parse poi data for task: " + this.toString() + ", poi data will be lost", thr2);
+                LOGGER.error("Failed to run parse poi data for task: " + this + ", poi data will be lost", thr2);
                 return new TaskResult<>(PoiChunk.empty(this.world, this.chunkX, this.chunkZ), null);
             }
         }
@@ -473,7 +473,7 @@ public final class ChunkLoadTask extends ChunkProgressionTask {
         @Override
         protected @NotNull TaskResult<CompoundTag, Throwable> runOffMain(final @Nullable CompoundTag data, final @Nullable Throwable throwable) {
             if (throwable != null) {
-                LOGGER.error("Failed to load entity data for task: " + this.toString() + ", entity data will be lost", throwable);
+                LOGGER.error("Failed to load entity data for task: " + this + ", entity data will be lost", throwable);
                 return new TaskResult<>(null, null);
             }
 
@@ -488,7 +488,7 @@ public final class ChunkLoadTask extends ChunkProgressionTask {
             } catch (final ThreadDeath death) {
                 throw death;
             } catch (final Throwable thr2) {
-                LOGGER.error("Failed to run converters for entity data for task: " + this.toString() + ", entity data will be lost", thr2);
+                LOGGER.error("Failed to run converters for entity data for task: " + this + ", entity data will be lost", thr2);
                 return new TaskResult<>(null, thr2);
             }
         }
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
index 9fad2a7b575a58e45b5092b4f363c3fe06d7a733..3e5edc02d98acf6a9235b01bba6abc29477e50d6 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkTaskScheduler.java
@@ -774,7 +774,7 @@ public final class ChunkTaskScheduler {
                     MCUtil.dumpChunks(file, true);
                     LOGGER.error("Successfully written chunk information!");
                 } catch (final Throwable thr) {
-                    MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file.toString(), thr);
+                    MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file, thr);
                 }
             }
         }
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java
index 2108c08d899d17f512ba053433a28a17ed636113..01a80af3e5f386905a35ac64752a9a92148a5639 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkUpgradeGenericStatusTask.java
@@ -124,7 +124,7 @@ public final class ChunkUpgradeGenericStatusTask extends ChunkProgressionTask im
         }
 
         if (!completeFuture.isDone() && !this.toStatus.warnedAboutNoImmediateComplete.getAndSet(true)) {
-            LOGGER.warn("Future status not complete after scheduling: " + this.toStatus.toString() + ", generate: " + generation);
+            LOGGER.warn("Future status not complete after scheduling: " + this.toStatus + ", generate: " + generation);
         }
 
         final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either;
@@ -143,7 +143,7 @@ public final class ChunkUpgradeGenericStatusTask extends ChunkProgressionTask im
         }
 
         if (newChunk == null) {
-            this.complete(null, new IllegalStateException("Chunk for status: " + ChunkUpgradeGenericStatusTask.this.toStatus.toString() + ", generation: " + generation + " should not be null! Either: " + either).fillInStackTrace());
+            this.complete(null, new IllegalStateException("Chunk for status: " + ChunkUpgradeGenericStatusTask.this.toStatus + ", generation: " + generation + " should not be null! Either: " + either).fillInStackTrace());
             return;
         }
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java
index 137c9059d3519fc86f5457d5a2f83d0db65d9307..b6e0c58b68101c90f81100ca5a4d5c45c3d28f94 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/GenericDataLoadTask.java
@@ -281,7 +281,7 @@ public abstract class GenericDataLoadTask<OnMain,FinalCompletion> {
             } catch (final ThreadDeath death) {
                 throw death;
             } catch (final Throwable thr2) {
-                LOGGER.error("Failed I/O callback for task: " + GenericDataLoadTask.this.toString(), thr2);
+                LOGGER.error("Failed I/O callback for task: " + GenericDataLoadTask.this, thr2);
                 GenericDataLoadTask.this.scheduler.unrecoverableChunkSystemFailure(
                     GenericDataLoadTask.this.chunkX, GenericDataLoadTask.this.chunkZ, Map.of(
                         "Callback throwable", ChunkTaskScheduler.stringIfNull(throwable)
diff --git a/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java b/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
index c48e64ad8e059b6b68574c8d1ce62ff12449b104..9d4f27ed3765d0ad49b9c2c61211dcf040f2683b 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
@@ -252,7 +252,7 @@ public final class ChunkDebugCommand implements PaperSubcommand {
                     MCUtil.dumpChunks(file, false);
                     sender.sendMessage(text("Successfully written chunk information!", GREEN));
                 } catch (Throwable thr) {
-                    MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file.toString(), thr);
+                    MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file, thr);
                     sender.sendMessage(text("Failed to dump chunk information, see console", RED));
                 }
             }
diff --git a/src/main/java/net/minecraft/nbt/NbtUtils.java b/src/main/java/net/minecraft/nbt/NbtUtils.java
index 903e126facf5d8abb9520e8385faba65924fdbb1..b70968f18842684309bcb33d34c74fb427aea1b3 100644
--- a/src/main/java/net/minecraft/nbt/NbtUtils.java
+++ b/src/main/java/net/minecraft/nbt/NbtUtils.java
@@ -253,7 +253,7 @@ public final class NbtUtils {
         if (optional.isPresent()) {
             return state.setValue(property, optional.get());
         } else {
-            LOGGER.warn("Unable to read property: {} with value: {} for blockstate: {}", key, properties.getString(key), root.toString());
+            LOGGER.warn("Unable to read property: {} with value: {} for blockstate: {}", key, properties.getString(key), root);
             return state;
         }
     }
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 9206f5e3985a2d253a51f42505f5a11517e08058..245a182838c9888dab3301b487860da7390532c7 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -464,7 +464,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
                     net.minecraft.server.MCUtil.dumpChunks(file, true);
                     sender.sendMessage(net.kyori.adventure.text.Component.text("Successfully written chunk information!", net.kyori.adventure.text.format.NamedTextColor.GREEN));
                 } catch (Throwable thr) {
-                    MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file.toString(), thr);
+                    MinecraftServer.LOGGER.warn("Failed to dump chunk information to file " + file, thr);
                     sender.sendMessage(net.kyori.adventure.text.Component.text("Failed to dump chunk information, see console", net.kyori.adventure.text.format.NamedTextColor.RED));
                 }
             };
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index a29f7fcd0ad54e2fcfb0a6be101b1c64716e8cd7..a8bc1b37d13504b45357b7e6c9f3d23a20026f71 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -393,7 +393,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             ChunkPos nbtPos = nbt == null ? null : EntityStorage.readChunkPos(nbt);
             if (nbtPos != null && !pos.equals(nbtPos)) {
                 throw new IllegalArgumentException(
-                    "Entity chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + pos.toString()
+                    "Entity chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + pos
                         + " but compound says coordinate is " + nbtPos + " for world: " + this
                 );
             }
@@ -1428,7 +1428,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         Entity entity = (Entity) this.getEntities().get(player.getUUID());
 
         if (entity != null) {
-            ServerLevel.LOGGER.warn("Force-added player with duplicate UUID {}", player.getUUID().toString());
+            ServerLevel.LOGGER.warn("Force-added player with duplicate UUID {}", player.getUUID());
             entity.unRide();
             ServerLevel.removePlayerImmediately((ServerPlayer) entity, Entity.RemovalReason.DISCARDED);
         }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 0a72bc2bab436eab8606c9bbccd747a08eba41cc..bb86b48462ee564449776c1226cad25d982579fd 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -1257,7 +1257,7 @@ public class LevelChunk extends ChunkAccess {
         }
 
         public String toString() {
-            return this.ticker.toString() + " <wrapped>";
+            return this.ticker + " <wrapped>";
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
index 311f8d2e9f3d9f59acee085cc35889287f1a8fb3..c33d203998060f0837eb66def36848818ebd62cb 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkStorage.java
@@ -180,8 +180,8 @@ public class ChunkStorage implements AutoCloseable {
         // Paper start
         if (!chunkPos.equals(ChunkSerializer.getChunkCoordinate(nbt))) {
             String world = (this instanceof net.minecraft.server.level.ChunkMap) ? ((net.minecraft.server.level.ChunkMap)this).level.getWorld().getName() : null;
-            throw new IllegalArgumentException("Chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + chunkPos.toString()
-                + " but compound says coordinate is " + ChunkSerializer.getChunkCoordinate(nbt).toString() + (world == null ? " for an unknown world" : (" for world: " + world)));
+            throw new IllegalArgumentException("Chunk coordinate and serialized data do not have matching coordinates, trying to serialize coordinate " + chunkPos
+                + " but compound says coordinate is " + ChunkSerializer.getChunkCoordinate(nbt) + (world == null ? " for an unknown world" : (" for world: " + world)));
         }
         // Paper end
         this.regionFileCache.write(chunkPos, nbt);
diff --git a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
index 601f8099f74e81c17600566b3c9b7a6dd39c9bcb..ba2f0b3c7ab09b685e2e33089e93d8d549253aeb 100644
--- a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
@@ -58,7 +58,7 @@ public class PlayerDataStorage {
             boolean usingWrongFile = false;
             if ( org.bukkit.Bukkit.getOnlineMode() && !file.exists() ) // Paper - Check online mode first
             {
-                file = new File( this.playerDir, java.util.UUID.nameUUIDFromBytes( ( "OfflinePlayer:" + player.getScoreboardName() ).getBytes( "UTF-8" ) ).toString() + ".dat");
+                file = new File( this.playerDir, java.util.UUID.nameUUIDFromBytes( ( "OfflinePlayer:" + player.getScoreboardName() ).getBytes( "UTF-8" ) ) + ".dat");
                 if ( file.exists() )
                 {
                     usingWrongFile = true;
@@ -85,7 +85,7 @@ public class PlayerDataStorage {
             if (player instanceof ServerPlayer) {
                 CraftPlayer player1 = (CraftPlayer) player.getBukkitEntity();
                 // Only update first played if it is older than the one we have
-                long modified = new File(this.playerDir, player.getUUID().toString() + ".dat").lastModified();
+                long modified = new File(this.playerDir, player.getUUID() + ".dat").lastModified();
                 if (modified < player1.getFirstPlayed()) {
                     player1.setFirstPlayed(modified);
                 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index f3adb921f9b2a658b87c4c6a1b10805477204689..81ab1d6113d84119f30c063bac4fe6c1a1c4b901 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1094,7 +1094,7 @@ public final class CraftServer implements Server {
         try {
             perms = (Map<String, Map<String, Object>>) this.yaml.load(stream);
         } catch (MarkedYAMLException ex) {
-            this.getLogger().log(Level.WARNING, "Server permissions file " + file + " is not valid YAML: " + ex.toString());
+            this.getLogger().log(Level.WARNING, "Server permissions file " + file + " is not valid YAML: " + ex);
             return;
         } catch (Throwable ex) {
             this.getLogger().log(Level.WARNING, "Server permissions file " + file + " is not valid YAML.", ex);
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index b02f00eee359fbd14b4694f5088d3e23a9db57e2..c1431a6fc52c0659519fb2010e98034ce049341e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -470,7 +470,7 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
             mcMerchant = ((CraftMerchantCustom) merchant).getMerchant();
             name = ((CraftMerchantCustom) merchant).getMerchant().getScoreboardDisplayName();
         } else {
-            throw new IllegalArgumentException("Can't open merchant " + merchant.toString());
+            throw new IllegalArgumentException("Can't open merchant " + merchant);
         }
 
         mcMerchant.setTradingPlayer(this.getHandle());
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 664a742a0a488eb57f562040cda49867f4e2183a..f7dcf4a445fd208ec5b723b9a3e7125525cb8aa4 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -1794,7 +1794,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
                 resource = CraftNamespacedKey.fromMinecraft(key);
             }
         } catch (IllegalArgumentException ex) {
-            org.bukkit.Bukkit.getLogger().warning("Namespaced resource does not validate: " + key.toString());
+            org.bukkit.Bukkit.getLogger().warning("Namespaced resource does not validate: " + key);
             ex.printStackTrace();
         }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/metadata/EntityMetadataStore.java b/src/main/java/org/bukkit/craftbukkit/metadata/EntityMetadataStore.java
index f6be08778ecb6d085eb1d273bd84cde07f50f354..ea049d326ca7ce02463d70822b73e68e74d9091e 100644
--- a/src/main/java/org/bukkit/craftbukkit/metadata/EntityMetadataStore.java
+++ b/src/main/java/org/bukkit/craftbukkit/metadata/EntityMetadataStore.java
@@ -20,6 +20,6 @@ public class EntityMetadataStore extends MetadataStoreBase<Entity> implements Me
      */
     @Override
     protected @NotNull String disambiguate(@NotNull Entity entity, String metadataKey) {
-        return entity.getUniqueId().toString() + ":" + metadataKey;
+        return entity.getUniqueId() + ":" + metadataKey;
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/metadata/WorldMetadataStore.java b/src/main/java/org/bukkit/craftbukkit/metadata/WorldMetadataStore.java
index 38c9981d03aa73a82284be73f16d832c6647b942..68e5505ed0b626ed2b59b9ccb423d466136aef80 100644
--- a/src/main/java/org/bukkit/craftbukkit/metadata/WorldMetadataStore.java
+++ b/src/main/java/org/bukkit/craftbukkit/metadata/WorldMetadataStore.java
@@ -19,6 +19,6 @@ public class WorldMetadataStore extends MetadataStoreBase<World> implements Meta
      */
     @Override
     protected @NotNull String disambiguate(@NotNull World world, String metadataKey) {
-        return world.getUID().toString() + ":" + metadataKey;
+        return world.getUID() + ":" + metadataKey;
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftNBTTagConfigSerializer.java b/src/main/java/org/bukkit/craftbukkit/util/CraftNBTTagConfigSerializer.java
index 61652fa1cb36ac23ef1f08d0748ab47029a345a9..7f9e1d909a25ffde5490bae4344034d52c596be8 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftNBTTagConfigSerializer.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftNBTTagConfigSerializer.java
@@ -43,7 +43,7 @@ public class CraftNBTTagConfigSerializer {
         } else if (base instanceof StringTag) {
             return base.getAsString();
         } else if (base instanceof IntTag) { // No need to check for doubles, those are covered by the double itself
-            return base.toString() + "i";
+            return base + "i";
         }
 
         return base.toString();
diff --git a/src/main/java/org/spigotmc/TicksPerSecondCommand.java b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
index 4a00841a53ca74b2b248fdd91c7f9913d1b37d1d..76646d414b65c7dfd9311cfd02768ee1f26d9525 100644
--- a/src/main/java/org/spigotmc/TicksPerSecondCommand.java
+++ b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
@@ -49,7 +49,7 @@ public class TicksPerSecondCommand extends Command
     private boolean hasShownMemoryWarning; // Paper
     private static @NotNull String format(double tps) // Paper - Made static
     {
-        return ( ( tps > 18.0 ) ? ChatColor.GREEN : ( tps > 16.0 ) ? ChatColor.YELLOW : ChatColor.RED ).toString()
+        return ( ( tps > 18.0 ) ? ChatColor.GREEN : ( tps > 16.0 ) ? ChatColor.YELLOW : ChatColor.RED )
                 + ( ( tps > 21.0 ) ? "*" : "" ) + Math.min( Math.round( tps * 100.0 ) / 100.0, 20.0 ); // Paper - only print * at 21, we commonly peak to 20.02 as the tick sleep is not accurate enough, stop the noise
     }
 }
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index 710f71739486b71523c37b0ae2746f7cd32fd340..7bc9f5f8a1b60686fc1fabb809076694ff08dd1c 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -55,7 +55,7 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
         if (moveVec != null) {
             log.log(Level.SEVERE, "Move call information: ");
             log.log(Level.SEVERE, "Start position: (" + moveStartX + ", " + moveStartY + ", " + moveStartZ + ")");
-            log.log(Level.SEVERE, "Move vector: " + moveVec.toString());
+            log.log(Level.SEVERE, "Move vector: " + moveVec);
         }
     }
 
