From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: camdenorrb <me@12oclock.dev>
Date: Sat, 22 Oct 2022 04:05:48 -0500
Subject: [PATCH] Use Math.min


diff --git a/src/main/java/io/papermc/paper/util/PoiAccess.java b/src/main/java/io/papermc/paper/util/PoiAccess.java
index a2f0906b0eb93836978337a90012f041f636d18f..c7c76bb066fafae866e37b1fb96befcb8bb4810a 100644
--- a/src/main/java/io/papermc/paper/util/PoiAccess.java
+++ b/src/main/java/io/papermc/paper/util/PoiAccess.java
@@ -31,7 +31,7 @@ import java.util.function.Predicate;
 public final class PoiAccess {
 
     protected static double clamp(final double val, final double min, final double max) {
-        return (val < min ? min : (val > max ? max : val));
+        return (val < min ? min : (Math.min(val, max)));
     }
 
     protected static double getSmallestDistanceSquared(final double boxMinX, final double boxMinY, final double boxMinZ,
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index ca84eddbdb1e198b899750e5f6b3eafd25ce970f..7721872c953ecb151a7d34f922954838a31fe941 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -681,7 +681,7 @@ public class ServerChunkCache extends ChunkSource {
                 // copied and modified from isOutisdeRange
                 int chunkRange = level.spigotConfig.mobSpawnRange;
                 chunkRange = (chunkRange > viewDistance) ? (byte)viewDistance : chunkRange;
-                chunkRange = (chunkRange > DistanceManager.MOB_SPAWN_RANGE) ? DistanceManager.MOB_SPAWN_RANGE : chunkRange;
+                chunkRange = Math.min(chunkRange, DistanceManager.MOB_SPAWN_RANGE);
 
                 com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(player.getBukkitEntity(), (byte)chunkRange);
                 event.callEvent();
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index fff74ea2cb90451cadc96af04ace3b22863378fb..eb0b18b525ee560422d461809b529c2a809f0bb5 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -280,11 +280,7 @@ public class Inventory implements Container, Nameable {
             this.setItem(slot, itemstack1);
         }
 
-        int k = j;
-
-        if (j > itemstack1.getMaxStackSize() - itemstack1.getCount()) {
-            k = itemstack1.getMaxStackSize() - itemstack1.getCount();
-        }
+	    int k = Math.min(j, itemstack1.getMaxStackSize() - itemstack1.getCount());
 
         if (k > this.getMaxStackSize() - itemstack1.getCount()) {
             k = this.getMaxStackSize() - itemstack1.getCount();
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index b5bb135967d7071443722f4ba295544cb8e450ff..b5b7c048d71bb66b9cad39827b4a51e0d9c19321 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -1950,7 +1950,7 @@ public abstract class Player extends LivingEntity {
         if (!this.level.getGameRules().getBoolean(GameRules.RULE_KEEPINVENTORY) && !this.isSpectator()) {
             int i = this.experienceLevel * 7;
 
-            return i > 100 ? 100 : i;
+            return Math.min(i, 100);
         } else {
             return 0;
         }
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 61884e22f966581a23d90ca910cac94c38a1d769..da38bcf59be3f8873b42b97d08b1e5a624158b86 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -594,10 +594,7 @@ public class Block extends BlockBehaviour implements ItemLike {
         if (value < min) {
             return min;
         }
-        if (value > max) {
-            return max;
-        }
-        return value;
+        return Math.min(value, max);
     }
     // Spigot end
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 36cc4540285958aa01c7bfc73e91eebff233ad24..091fbf633397dcb5d99449d47c80ac6552d3e215 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -291,7 +291,7 @@ public class RegionFile implements AutoCloseable {
                     int sectorLength = (int)roundToSectors(rawLength);
 
                     if (newSectorAllocations.tryAllocate(sectorOffset, sectorLength)) {
-                        calculatedOffsets[location] = sectorOffset << 8 | (sectorLength > 255 ? 255 : sectorLength); // support forge style oversized
+                        calculatedOffsets[location] = sectorOffset << 8 | (Math.min(sectorLength, 255)); // support forge style oversized
                     } else {
                         LOGGER.error("Failed to allocate space for local chunk (overlapping data??) at (" + chunkX + "," + chunkZ + ") in regionfile " + this.regionFile.toAbsolutePath() + ", chunk will be regenerated");
                     }
@@ -314,7 +314,7 @@ public class RegionFile implements AutoCloseable {
                     try {
                         this.file.write(this.createExternalStub(oversizedCompressionTypes[location]), sectorOffset * 4096);
                         // only allocate in the new offsets if the write succeeds
-                        calculatedOffsets[location] = sectorOffset << 8 | (sectorLength > 255 ? 255 : sectorLength); // support forge style oversized
+                        calculatedOffsets[location] = sectorOffset << 8 | (Math.min(sectorLength, 255)); // support forge style oversized
                     } catch (IOException ex) {
                         newSectorAllocations.free(sectorOffset, sectorLength);
                         LOGGER.error("Failed to write new oversized chunk data holder, local chunk at (" + chunkX + "," + chunkZ + ") in regionfile " + this.regionFile.toAbsolutePath() + " will be regenerated");
